\documentclass[11pt]{article}

\usepackage{sectsty}
\usepackage{graphicx}
\usepackage[T1]{fontenc}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\title{ Zastosowanie ECS oraz wielowątkowości do symulacji systemów cząsteczek } 
\author{ Gabriel Kaszewski }
\date{\today}

\begin{document}
\maketitle	
\pagebreak

% Optional TOC
% \tableofcontents
% \pagebreak

\section{Wprowadzenie}

\subsection{Cel pracy}
Celem pracy jest stworzenie szkieletu (ang. framework) aplikacji do tworzenia wszelakich symulacji systemów cząsteczek.
Przykładowymi symulacjami mogą być: symulacja gazu, płynów, dynamiki białek, co może być przydatne w bioinformatyce.
W tej pracy przykładowym system cząsteczek będzie 'Gra w życie' Johna Conwaya. Wspomniany przeze mnie szkielet powinien
móc umożliwiać tworzenie wydajnej symulacji w oparciu o architekturę ECS (Entity Component System) oraz stosować
w jak najszerszym zakresie techniki wielowątkowości, tam gdzie jest to możliwe i uzasadnione.

\subsection{Technologie}
W pracy wykorzystane zostaną następujące technologie:
\begin{itemize}
    \item Rust - język programowania
    \item \texttt{bevy\_ecs} - biblioteka do ECS
    \item \texttt{bevy} - silnik do gier (wyświetlanie symulacji + interakcja z użytkownikiem)
\end{itemize}

\textbf{Rust} jest językiem programowania, który jest kompilowany do kodu maszynowego, jest to ogromna zaleta
i główny powód dla, którego wybrałem go zamiast języka Python. Co więcej, przez to, że Rust jest kompilowany to
można go do tworzenia aplikacji na wiele platform, w tym przeglądarki internetowe poprzez WASM (WebAssembly).
Kolejną zaletą Rusta jest to, że jest zaprojektowany w taki sposób, by pisanie programów wielowątkowych było
jak najłatwiejsze, jest to możliwe poprzez mechanizm \textbf{własności} (ang. ownership) oraz \textbf{wypożyczeń}
(ang. borrowing). Mechanizmy te kontrolują dostęp do pamięci (obiekt może być zmieniany, mutowany tylko przez jedną jednostkę w tym samym czasie).
W Rustcie programista również ma kontrolę nad pamięcia, co pozwala na tworzenie aplikacji o bardzo niskim zużyciu pamięci.
Co będzie przydatne w przypadku symulacji, gdzie może być potrzeba przechowywania milionów obiektów.

\textbf{bevy\_ecs} jest biblioteką do ECS, która jest napisana w Rustcie. Została stworzona na potrzeby silnika do gier \textbf{Bevy}.
Postanowiłem użyć tej biblioteki, ponieważ jest prosta w użyciu, wydajna i posiada bardzo dobrą dokumentację. Co więcej zawiera
planistę (ang. scheduler), który pozwala na łatwe tworzenie wielowątkowych aplikacji, gdyż uruchamia systemy (ang. systems) równolegle,
gdy tylko to możliwe.

\textbf{bevy} jest silnikiem do gier napisanym w Rustcie, oparty jest na architekturze ECS. Postanowiłem
wykorzystać bevy, gdyż zawiera on wszystko co jest potrzebne do wyświetlania symulacji oraz interakcji z użytkownikiem
(np. obsługa klawiatury, myszki). Co przyda się przy tworzeniu edytora do symulacji.

\section{ECS}
\subsection{Wstęp do ECS}
ECS (Entity Component System) to architektura projektowania oprogramowania, która oddziela logikę od danych,
różniąc się tym samym od tradycyjnego podejścia obiektowego. W podejściu ECS, logika i dane są rozdzielone:
dane są przechowywane w komponentach (ang. components), a logika w systemach (ang. systems). Encje (ang. entities)
służą jako identyfikatory, grupujące komponenty. Taka architektura sprzyja elastyczności, łatwiejszemu zarządzaniu kodem
i wydajności, szczególnie w przypadku symulacji systemów cząsteczek. Co więcej ECS jest dość naturalnym podejściem
programowania w Rust, gdyż Rust nie posiada klas oraz innych mechanizmów obiektowych, które są dostępne w innych językach
programowania takich jak Python czy Java.

\subsection{Encje}
\textbf{Encje (ang. entities)} są podstawowymi jednostkami w architekturze ECS. Są to zazwyczaj lekkie struktury zawierające
unikalny identyfikator (ang. id), często jest to po prostu liczba całkowita; które nie zawierają bezpośrednio żadnych danych
bądź logiki. Rola encji sprowadza się do reprezentowania obiektów w symulacji, np. poszczególnych cząsteczek, bądź komórek.
Encje mogą być dynamicznie tworzone, modyfikowane i usuwane w trakcie działania programu, co pozwala na sporą
elastyczność i skalowalność.

\subsection{Komponenty}
\textbf{Komponenty (ang. components)} to są kontenery na dane. W ECS, dane dotyczące stanu obiektów
(takie jak pozycja, kolor, żywotność itd.) są oddzielone od logiki i przechowywane w komponentach. Każdy
komponent zawiera informację dotyczące tylko jednego aspektu encji, np. komponent \texttt{Pozycja} może przechowywać
informacje o położeniu cząsteczki w przestrzeni. Ta modularność pozwala na łatwe dodawanie, usuwanie
i modyfikowanie własności encji bez ingerencji w cała strukturę programu.

\subsection{Systemy}
\textbf{Systemy (ang. systems)} to nic innego jak funkcje, które są odpowiedzialne za przetwarzanie logiki w architekturze ECS.
Każdy system operuje na jednym lub więcej typach komponentów, np. system \texttt{Ruch} może operować na komponentach
\texttt{Pozycja} i \texttt{Prędkość}, wykonując określone zadania takie jak aktualizacja pozycji cząsteczki na podstawie jej prędkości.
Systemy mogą być zaprojektowane do pracy w sposób niezależny od siebie, co umożliwia łatwe wykorzystanie wielowątkowości. 
Zalecane jest projektowanie systemów w taki sposób, by były jak najbardziej niezależne od siebie. Każdy z systemów
jest uruchamiany przez planistę (ang. scheduler) w każdej klatce symulacji. Planista stara się uruchomić systemy
w sposób równoległy, gdy tylko jest to możliwe. Systemy również powinny być projektowane w taki sposób, by
każdy system był odpowiedzialny za jak najmniejszą ilość pracy (zasada SRP - Single Responsibility Principle).

\subsection{Świat}
\textbf{Świat (ang. world)} to struktura, która przechowuje wszystkie encje i komponenty w programie.
Jest to nasz główny punkt dostępu do wszystkich danych i logiki w naszej symulacji. Również przekazywany
jest on do planisty, który potem przekazuje systemom odpowiednie dane do przetworzenia.

\subsection{Zalety ECS}
Jak już wielokrotnie wspomniałem, architektura ECS oferuje szerg zalet jak:
\begin{itemize}
    \item \textbf{Modularność:} Łatwość dodawnia nowych typów danych i logiki.
    \item \textbf{Elastyczność:} Możliwość dynamicznego tworzenia, modyfikowania i usuwania komponentów oraz encji.
    \item \textbf{Separacja danych i logiki:} Ułatwia zarządzanie kodem i redukuje zależności.
    \item \textbf{Skalowalność:} Umożliwia efektywne zarządzanie dużą liczbą obiektów, co jest kluczowe 
    w symulacji systemów cząsteczek.
    \item \textbf{Wydajność:} Lepsze wykorzystanie zasobów systemowych, w tym wielowątkowości.
\end{itemize}

\subsection{Wielowątkowość w ECS}
\textbf{ECS} naturalnie wspiera wielowątkowość. Głównie dlatego, że systemy mogą działać niezależnie na różnych zestawach
komponentów, co pozwala na rozdzielenie pracy na wiele wątków. To pozwala na równoczesne przetwarzanie różnych aspektów
symulacji, co jest szczególnie istotne przy dużych liczbach obiektów i złożonych interakcjach między nimi.

\subsection{Podsumowanie}
Architektura ECS to potężne narzędzie w symulacjach oraz grach, oferuje ono elastyczność, modularność i 
wydajność. W połączeniu z wielowątkowością, ECS stanowi idealne rozwiązanie do tworzenia
skalowalnych i wydajnych symulacji, które jednocześnie są łatwe w utrzymaniu i rozbudowie.

\section{Gra w życie}
\subsection{Wprowadzenie}
Gra w życie (ang. Conway's Game of Life) to automat komórkowy wymyślony przez brytyjskiego matematyka Johna Conwaya w 1970 roku.
Symulacją kieruje się na prostych zasadach, które mogą prowadzić do złożonych zachowań.
W symulacji mamy planszę, która składa się z komórek. Każda komórka może mieć jeden z dwóch stanów: żywy lub martwy.
Stan zmienia się w zależności od liczby sąsiadów, którzy są żywi.
Reguły są następujące:
\begin{itemize}
    \item Jeśli żywa komórka ma mniej niż 2 żywych sąsiadów, to umiera z samotności.
    \item Jeśli żywa komórka ma 2 lub 3 żywych sąsiadów, to żyje dalej.
    \item Jeśli żywa komórka ma więcej niż 3 żywych sąsiadów, to umiera z przeludnienia.
\end{itemize}
Wydawać by się mogło, że zasady są proste, ale symulacja może prowadzić do bardzo złożonych zachowań, włącznie z
tworzeniem struktur, które same się replikują, bądź poruszają. Oraz jest możliwość zrobienia gry w życie w grze w życie.
\subsection{Zastosowanie ECS}
\subsection{Wielowątkowość}
\subsection{Optymalizacja przestrzenna}
\subsection{Podsumowanie}

\section{Szkielet}

\section{Przyszłość}

\section{Podsumowanie}

\end{document}